# 前言

上一篇看得懂的字节码讲了怎么看字节码，以及字节码中的魔数、版本号和常量池部分，这篇文章接着字节码顺序往下将。请一定要看了上一篇之后再看这一篇，因为有绝对的逻辑关系，不看上一篇这篇基本看不懂。

如果这篇文章中有我没有讲到怎么出现的东西，（比如程序的代码，javap工具，查看字节码的工具等）就是我在上一篇文章中已经提到过的，可以查看我的上一篇文章来找到答案。

上一篇地址 [能看懂的字节码-上](https://github.com/leosanqing/Java-Notes/blob/master/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81-%E4%B8%8A.md)

# 文章大纲



# 访问标志

紧接着常量池后面的两个字节(u2类型)就表示访问的标志，在字节码中是这两个数

![](img/Xnip2019-04-23_12-07-39.jpg)

那么他代表什么呢？他表示这个类或者接口声明为 **public**

我们看他的所有含义的表

![](img/Xnip2019-04-23_12-11-50.jpg)

21就是 ACC_PUBLIC 和 ACC_SUPER 这两个标志值相或的结果。即 0x0001 | 0x0020 = 0x0021。

而我们的代码中为

```java
public class TestClass {
  .......
}
```



> 你可以试下将它声明为 private 或者其他情况是什么值

# 类索引、父类索引与接口索引

## 是什么

这三个非常类似，所以放在一起讲。**类索引和父类索引都是u2的数据。接口索引是一组u2类型的数据**。因为Java只能单继承，但是可以实现多个接口

- 类索引和父类索引都是指向一个类型为**CONSTANT_Class_info**的类描述符常量，通过这个的**索引值**我们可以找到定义在**CONSTANT_Utf8_info**中的全限定名字符串
- 接口索引前面有一个接口计数器(interfaces_count)，表示后面索引的容量。如果为零，那么就表示后面的索引表不占任何字符。

## 怎么看

我们回到字节码文件，接着上次看到的 0x0021.

![](img/Xnip2019-04-23_16-51-20.jpg)

后面是 0x0003, 0x0004,0x0000。这些啥意思呢？

刚刚说了指向**CONTANT_Class_info**，而这个class_info 存了全限定名的信息，结构如下

![](img/Xnip2019-04-23_17-28-27.jpg)

在上一篇我也说了，因为他已经确定了类型，所以是没有tag的位置的，就只有后面的index。所以0x0003表示它指向 第三个常量。第三个常量是什么呢？

我们回到命令行的内容(这个在上篇介绍过怎么打开的)，

![](img/Xnip2019-04-23_09-41-33.jpg)

第三个常量指向第17个常量，第17个常量是一个 uft8类型的。他的信息为·`com/swu/leosanqing/TestClass`。这个不就是该类的名称吗？

同理，我们找到 0x0004指向的含义，他是指向第18个常量，第18个常量也是一个**utf8**类型的数据，所存储的信息为 `java/lang/Object`，这个类不就是我们TestClass的父类吗/

0x0000 表示这个类没有实现接口(或者这个接口没有继承其他接口)，所以这三个就已经解析完了。

# 字段表

## 是什么

![](img/Xnip2019-04-23_19-34-29.jpg)

**字段表（field_info）用于描述接口或类中声明的变量，字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量**

而这个field_info是一个这样的结构

![](img/Xnip2019-04-23_21-23-43.jpg)

他跟之前的**类的访问标志很像**，都是u2类型的数据，但是有一些差别

![](img/Xnip2019-04-23_21-23-51.jpg)

![](img/Xnip2019-04-23_12-11-50.jpg)



如果是相同的话，那么他们的**标志值**是一模一样的

紧随**access_flags**后面的两个是 **name_index**和**descriptor_index**,这两个分别表示字段的**简单名称**以及**字段和方法的描述符**。

## 简单名称

**简单名称**是指**没有类型和参数修饰**的**方法或者字段的名字**，比如我们定义的方法

```java
public class TestClass {

    private int m;

    public int inc(){
        return m+1;
    }
}
```

那么简单名称就是 "inc"和"m".等会儿你跟着我翻译一下字节码就知道了

**字段和方法的描述符**稍微复杂一些，他的**作用**是用来描述字段的数据类型、方法的参数列表（包括数量、类型和顺序，看到这三个有没有想到啥？没错，**重载**！等下就知道重载为啥要三个不一样）和返回值。

根据描述符规则，**基本数据类型**(byte，short，int…….)以及**代表无返回值的void类型**都用一个**大写字符**来表示，而**对象类型则用字符L+对象的全限定名来表示**。

![](img/Xnip2019-04-23_22-02-27.jpg)

对于数组来说，每一个字符将使用一个前置的"["字符来描述，

下面我来分别举个例子

```java
/* 如果我要表示一个整形数组 int[]
		那么就应该表示为  [I
		
		如果我要表示一个二维的数组char[][]
		那么就应该表示为 [[C
		
		如果我要表示一个二维的字符串数组String[][]
		那么就应该表示为  [[Ljava/lang/String; 注意有分号
		因为String不是基本类型也不是void类型，所以要用对象类型来描述
		所以他就应该用字符L+String类的全限定名来表示
		
		如果我要表示一个自定义的Person类，他在包 com.swu.leosanqing下
		那么就应该表示为 Lcom/swu/leosanqing/Person
		
*/
```

## 描述符(重要)

如果描述符（descriptor_index）要描述一个方法的话，按照**先参数列表**，**后返回值的**顺序描述，参数列表按照参数的严格顺序放在一组小括号"()"中。

下面我举几个例子

```java
/*
	先拿本程序举例，他有一个 方法  
	public int inc(){
        return m+1;
    }
    那么就应该表示为 "()I"
    
    假设 Person类 在包 "com.swu.leosanqing"下
    如果一个方法为 public Person (char[] source,int[] a,char[][] c,int b,int c,String d).
    那么他就应该表示为 			         ([C[I[[CIILjava/lang/String;)Lcom/swu/leosanqing;
  
*/
```

这个后面的方法表集合中会用到

## 怎么看

我们接着类索引、父类索引和接口索引往下看。



![](img/Xnip2019-04-23_22-38-54.jpg)

我们对着下面的表进行一一对应，他前面还有一个 `field_count`

![](img/Xnip2019-04-23_22-46-09.jpg)

![](img/Xnip2019-04-23_21-23-43.jpg)

0x0001对应`field_count`表示只有一个参数，因为代码中我们就只定义了一个 `private int m`

0x0002对应`access_flags`，然后我们查上面的表，它的意思为 字段是`private`

![](img/Xnip2019-04-23_21-23-51.jpg)

然后我们再看 0x0005，它对应的是u2类型的 `name_index`，我们应该找常量池中的第5个参数，我们通过命令行中的找，他的名字是 "m"

![](img/Xnip2019-04-23_22-51-47.jpg)



然后我们再往下走，0x0006 ,它对应`descriptor_index`，然后我们去常量池中寻找第6个常量，他是"I"，然后后面两个字节是0x0000，表示没有属性值。如果我的程序是 `private int m = 123;`那么后面的属性值就应该有表示的值

所以看下来，就是 private int m，跟我们程序中定义的是一模一样的，表明我们的解读正确。

## 字段无法重载

Java中没有用过字段的重载吧？也就是说我们不能在程序中这样定义。

```java
private int m;
public String m;

// 我们都知道这样做ide会报错，两个字段的数据类型、修饰符不管是否相同
// 都必须使用不一样的名字

//但是在字节码中就不一样，如果两个字段的描述符不一致，那么他是可以重名的，且是合法的
```

下一个小节将方法的重载，这个应该就稍微清晰一点

# 方法表

## 是什么

如果你理解了上一小节的内容，那么这一小节将会比较好懂，因为两个都差不多。

他就是**用来表示字节码中的方法的各种数据项**

![](img/Xnip2019-04-23_23-05-58.jpg)

你看这个表是不是很眼熟，和上一小节的字段表结构非常像？

访问标志也很像不过有些增减，比如加了方法的修饰符 native 的标志，删去了字段的 volatile 标志

![](img/Xnip2019-04-23_23-09-04.jpg)

## 方法里的代码去哪了

有没有发现，方法表结构并没有表示或者存放代码的内容，那么他去哪里了呢？他存放到**方法表中**的**属性表里**的 "**Code**"属性里。我会在下一节中讲到。

## 怎么看

我们先看下我们的方法对应字节码中的是哪些东西。这个刚好是接着上一节的字段表的位置开始的

![](img/Xnip2019-04-23_23-14-15.jpg)

跟上一节的字段表一样，首先他有一个表示方法多少的计数器"methods_count"，然后才是方法表(method_info)里面的数据，所以 0x0002表示里面有两个方法

然后我们再对应方法表来看

![](img/Xnip2019-04-23_23-05-58.jpg)

我们再看下一个 0x0001，它对应`access_flags`，我们查方法访问标志表，发现他是一个`public`

然后我们再看下一个0x0007，他对应



