jvm 垃圾回收



> Java 和 C++ 之间有一堵由内存动态分配

Java 由于JVM自带垃圾回收的机制，所以对于很多初中级的程序猿非常方便，不需要自己写语句控制垃圾的回收，只需要关注业务逻辑即可。尤其是自己写demo或者练手的项目，基本不用担心垃圾回收的事情



但是，对于线上的项目，一旦出现垃圾回收的问题，往往是非常致命的。所以不论是校招还是社招基本都会问到JVM的垃圾回收机制以及算法



这个文章的结构如下

- 哪些内存需要回收
- 什么时候回收
- 如何回收



# 哪些内存需要回收

主要分为两个部分

- 程序计数器，虚拟机栈，本地方法栈
- Java堆和方法区

> 如果你知道 JVM运行时数据区，那么应该知道上面的两部分刚好是按照线程共不共享来划分的。这样也方便记

如果不了解的话，可以参考我的这篇 JVM运行时数据区的文章

## 第一部分

刚刚也提到了，如果了解JVM运行时数据区的话，**第一部分的线程是不共享的**。**他们都随着线程生而生，线程灭而灭**。

这三个区域的内存分配和回收都具备确定性，不必过多考虑回收问题，在方法结束或者线程结束时，内存自然而然就跟着回收了

## 第二部分

基本是运行时才已知，且线程共享，基本上考虑垃圾回收算法以及回收判定都是这两个部分。

### 方法区的回收

在方法区的回收垃圾的性价比一般是比较低的

在JDK1.7或者1.8之前，很多人将方法区和Hotspot中的`永久代`等同。其实二者也是有区别的`前者是 JVM 的规范，而后者则是 JVM 规范的一种实现`

**注意：**只有 Hotspot中才有永久代（PermGen space）的概念，其他的JVM比如Oracle的JRocket和IBM的J9并没有这个概念。 而且永久代从JDK1.7之后就开始逐步移除了，1.8之后就已经完全移除，转为`元空间`

具体可以参考这篇博文，[永久代和元空间](https://www.cnblogs.com/paddix/p/5309550.html)

> 他主要回收的内容是**废弃常量**和**无用的类**

#### 废弃常量

以回收常量池中的字面量为例，如果一个字符串"abcd"已经加入了常量池，但是并没有任何String对象引用常量池中的 "abcd"常量

> 常量池中其他类(接口)、方法、字段的符号引用也与此类似

回收Java堆中的方式也与此类似

#### 无用的类

判定无用的类条件比较严苛，需要同时满足下列三个条件

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

> 注意这里仅仅是"可以"，而并不是和对象一样，不使用了就必然会回收

# 什么时候回收

当然是对象已经"死掉"的时候，主要有以下两种方法

- 可达性分析(JVM使用)
- 引用计数

## 引用计数法

### 思路

这个逻辑比较简单

- 给对象中添加一个引用计数器，
- 每当有一个地方引用它时，计数器值就加1
- 当引用失效时，计数器值就减1
- 当计数器为0的对象就是不可能再被使用的

### 缺点

但是这个方法有一个缺点：**互相引用的对象不会被回收**

比如有下面代码(除此之外没有其他引用，这两个对象也不会被访问，应该回收)

```java
obj1.instance = obj2;
obj2.instance = obj1;
```

对于使用 这种判定算法的虚拟机，并不会收到回收他们通知，就不会回收他们两个

## 可达性分析法

### 思路

- 通过一系列的称为 "GC Root"的对象作为起始点
- 从这些节点开始向下搜索，搜索走过的链称为`引用链`
- 当一个对象到 GC Root 没有任何引用链相连，则证明此对象是不可用的(用图论的话，就是GC Root到这个对象不可达)

### 可以作为GC Root的对象

- 虚拟机栈中引用的对象
- 本地方法栈中 JNI(即一般说的Native方法)引用的对象
- 本地方法区中
  - 类静态属性引用的对象
  - 常量引用的对象

> 即便是不可达的对象也不是立即进行回收，他会经历两次标记的过程

## 引用

不论是可达性分析算法还是引用计数法，要判定对象是否"死亡"，都需要根据引用来判定

在Java中一共有四种引用(JDK1.2之后)，强度依次递减

- 强引用(一定不会回收)
- 软引用(内存不够回收)
- 弱引用(发生回收就会回收)
- 虚引用()

### 强引用

`Strong Reference`在代码中普遍存在的，只要强引用存在，JVM就一定不会回收。

比如`Object obj = new Object();`

### 软引用

`Soft Reference`发生内存溢出异常之前，将这些软引用连接的对象列近回收范围之中的第二次回收。如果这次回收之后还没有足够的内存，才会抛出内存溢出异常

### 弱引用

`Weak Reference`只能活到下一次垃圾回收发生之前。无论内存是否足够，都会将软引用连接的对象回收

### 虚引用

`Phantom Reference`，他是最弱的一种引用关系。一个对象是否含有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例

**"为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知”**	 ————《深入理解Java虚拟机》

如果想多了解java四种引用的应用说明，可以参考下面这篇博文；

[java四大引用的特点及应用场景](https://www.jianshu.com/p/825cca41d962)

# 如何回收

回收有